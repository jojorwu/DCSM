# Архитектура Системы ДКОП (Динамическая Контекстуализированная Общая Память)

## 1. Введение

Система Динамической Контекстуализированной Общей Памяти (ДКОП) предназначена для эффективного управления знаниями в сложных, потенциально многоагентных системах. Она расширяет идеи подходов Cache-Augmented Generation (CAG) и Retrieval-Augmented Generation (RAG), фокусируясь на динамическом, распределенном и контекстуализированном доступе к информации. Основная цель - предоставить агентам релевантные знания в нужный момент, оптимизируя при этом использование ресурсов и способствуя совместному накоплению знаний.

## 2. Основные Принципы ДКОП

*   **Контекстуализированные Единицы Памяти (КЕП):** Знание не является монолитным, а разбивается на семантически связные "Контекстуализированные Единицы Памяти". Каждая КЕП содержит не только сам контент, но и богатые метаданные (тема, источник, актуальность, права доступа, векторные эмбеддинги и т.д.), что позволяет более гранулированно и интеллектуально управлять знанием.
*   **Иерархическая Структура Памяти:** Система использует многоуровневую память для баланса между скоростью доступа и объемом хранимой информации:
    *   **Глобальная/Долгосрочная Память (GLM):** Персистентное хранилище всех КЕП.
    *   **Общая Рабочая Память (SWM):** Активный, кэширующий слой для "горячих" КЕП, с которым взаимодействуют агенты.
    *   **Локальная Память Агента (ЛПА):** Краткосрочный кэш на стороне агента (реализуется в Agent SDK) для наиболее часто используемых им КЕП.
*   **Общая Шина Памяти:** Концептуально реализована через SWM, позволяет агентам "подписываться" на релевантные КЕП или "публиковать" новые, обеспечивая масштабируемость и гибкость.
*   **Динамическая Предварительная Загрузка и Вытеснение:** SWM динамически управляет своим кэшем, загружая релевантные КЕП из GLM и вытесняя менее актуальные.
*   **Межагентный Обмен Памятью:** Облегчается через публикацию КЕП в SWM, откуда они становятся доступны другим агентам или могут быть сохранены в GLM.

## 3. Компоненты Системы

### 3.1. Общие определения Protobuf (`dcs_memory/common/grpc_protos/`)

*   **Роль:** Определяют контракты данных (сообщения) и сервисов (gRPC) для взаимодействия между всеми компонентами системы. Обеспечивают строгую типизацию и межъязыковую совместимость.
*   **Ключевые файлы:**
    *   `kem.proto`: Определение Контекстуализированной Единицы Памяти (КЕП) - базовой структуры данных.
    *   `glm_service.proto`: API для Сервиса Глобальной/Долгосрочной Памяти.
    *   `kps_service.proto`: API для Сервиса Обработки Знаний.
    *   `swm_service.proto`: API для Сервиса Общей Рабочей Памяти.

### 3.2. Сервис Глобальной/Долгосрочной Памяти (GLM)

*   **Расположение:** `dcs_memory/services/glm/`
*   **Назначение:** Надежное и масштабируемое персистентное хранилище для всех КЕП в системе.
*   **Основные функции:**
    *   Сохранение КЕП, включая их контент, метаданные и векторные эмбеддинги.
    *   Извлечение КЕП по их уникальным идентификаторам.
    *   Комплексные запросы к КЕП с использованием фильтрации по метаданным, диапазонам дат.
    *   Векторный поиск по эмбеддингам для нахождения семантически близких КЕП.
    *   Обновление и удаление существующих КЕП.
*   **Технологии (текущая реализация):**
    *   gRPC для определения и предоставления API.
    *   Qdrant: используется как векторная база данных для хранения эмбеддингов и выполнения поиска по сходству.
    *   SQLite: используется для хранения структурированных метаданных и основного контента КЕП.
*   **API (gRPC - `glm_service.proto`):**
    *   `StoreKEM`: Сохраняет или обновляет одну КЕП. Генерирует ID, если не предоставлен.
    *   `RetrieveKEMs`: Извлекает КЕП по сложным критериям, включая фильтры, векторный запрос и пагинацию.
    *   `UpdateKEM`: Частично обновляет существующую КЕП по ее ID.
    *   `DeleteKEM`: Удаляет КЕП по ее ID.

### 3.3. Сервис Обработки Знаний (KPS)

*   **Расположение:** `dcs_memory/services/kps/`
*   **Назначение:** Точка входа для новых знаний в систему. Принимает сырые данные, обрабатывает их, генерирует эмбеддинги и формирует КЕП для последующего сохранения в GLM.
*   **Основные функции:**
    *   Прием сырых данных различных типов (например, текст, в перспективе другие форматы).
    *   Генерация векторных эмбеддингов для текстового контента с использованием моделей из библиотеки `sentence-transformers`.
    *   Формирование объектов КЕП, включая извлечение или получение `content_type`, `raw_content`, `initial_metadata` и добавление сгенерированных `embeddings`.
    *   Взаимодействие с GLM (через его gRPC клиент) для сохранения созданных КЕП.
*   **Технологии (текущая реализация):**
    *   gRPC для API.
    *   `sentence-transformers`: для генерации эмбеддингов.
    *   GLM gRPC клиент.
*   **API (gRPC - `kps_service.proto`):**
    *   `ProcessRawData`: Принимает сырые данные и метаданные, обрабатывает их и инициирует сохранение в GLM. Возвращает ID сохраненной КЕП и статус операции.

### 3.4. Сервис Общей Рабочей Памяти (SWM)

*   **Расположение:** `dcs_memory/services/swm/`
*   **Назначение:** Выступает в роли активного, быстрого кэширующего слоя памяти, с которым непосредственно взаимодействуют агенты. Управляет "горячими" КЕП, обеспечивает коллективный доступ и координацию.
*   **Основные функции (текущая базовая реализация):**
    *   **Кэширование активных КЕП:** Использует внутренний LRU-кэш для хранения часто используемых или недавно загруженных КЕП.
    *   **Загрузка из GLM:** По запросу (`LoadKEMsFromGLM`) извлекает КЕП из GLM и помещает их в свой кэш.
    *   **Запрос из кэша:** Предоставляет агентам интерфейс (`QuerySWM`) для запроса КЕП из кэша SWM с фильтрацией по ID, метаданным и датам.
    *   **Публикация КЕП:** Агенты могут публиковать КЕП в SWM (`PublishKEMToSWM`), которые сохраняются в кэше и опционально могут быть персистентно сохранены в GLM.
    *   **Подписка на события (заглушка):** Метод `SubscribeToSWMEvents` предназначен для подписки на изменения в SWM, но текущая реализация является заглушкой.
*   **Технологии (текущая реализация):**
    *   gRPC для API.
    *   `cachetools.LRUCache`: для внутреннего кэша.
    *   GLM gRPC клиент.
*   **API (gRPC - `swm_service.proto`):**
    *   `PublishKEMToSWM`: Публикация КЕП в SWM (и, возможно, в GLM).
    *   `SubscribeToSWMEvents`: Подписка на события SWM (текущая реализация - заглушка).
    *   `QuerySWM`: Запрос КЕП из кэша SWM с фильтрацией.
    *   `LoadKEMsFromGLM`: Инициирование загрузки КЕП из GLM в кэш SWM.

### 3.5. Agent SDK (`dcsm_agent_sdk_python`)

*   **Расположение:** `dcsm_agent_sdk_python/` (разрабатывался как отдельный пакет)
*   **Назначение:** Предоставление удобного Python-интерфейса для агентов для взаимодействия с сервисами ДКОП (GLM, SWM, KPS).
*   **Основные функции (реализовано для GLM, частично для SWM в перспективе):**
    *   Клиент для GLM (`GLMClient`) для прямого взаимодействия с долгосрочной памятью.
    *   Локальная Память Агента (`LocalAgentMemory` - LRU-кэш на стороне клиента).
    *   Высокоуровневые методы, комбинирующие ЛПА и удаленные вызовы.
    *   В перспективе: клиенты для SWM и KPS, реализация логики подписок на события SWM.

## 4. Взаимодействие Компонентов и Потоки Данных

### 4.1. Добавление новых знаний в систему (через KPS)

1.  **Инициатор** (например, внешний процесс, другой сервис, или агент через спец. интерфейс) отправляет сырые данные (текст, файл и т.д.) и начальные метаданные в **KPS** через его метод `ProcessRawData`.
2.  **KPS**:
    *   Декодирует контент, если это текст.
    *   Генерирует векторные эмбеддинги для текстового контента с помощью `sentence-transformers`.
    *   Формирует объект `KEM`, заполняя `content`, `content_type`, `embeddings`, `initial_metadata`.
    *   Вызывает метод `StoreKEM` у **GLM**, передавая сформированную КЕП (без ID, GLM его сгенерирует).
3.  **GLM**:
    *   Генерирует уникальный ID для КЕП.
    *   Устанавливает временные метки `created_at`, `updated_at`.
    *   Сохраняет эмбеддинги в Qdrant.
    *   Сохраняет остальные данные КЕП (ID, контент, метаданные, временные метки) в SQLite.
    *   Возвращает полную сохраненную КЕП (с ID и временными метками) обратно в KPS.
4.  **KPS** получает ответ от GLM и возвращает `kem_id` и статус операции инициатору запроса.

### 4.2. Получение знаний Агентом (через SWM и Agent SDK)

1.  **Агент** (через **Agent SDK**) запрашивает КЕП.
2.  **Agent SDK**:
    *   Сначала проверяет свою Локальную Память Агента (ЛПА). Если КЕП найдена, возвращает ее.
    *   Если в ЛПА нет, SDK обращается к **SWM** с запросом `QuerySWM`.
3.  **SWM**:
    *   Ищет КЕП в своем внутреннем кэше по критериям из `QuerySWM`.
    *   Если КЕП найдена в кэше, SWM возвращает ее в Agent SDK.
    *   Если КЕП не найдена в кэше, SWM (по запросу `LoadKEMsFromGLM`, инициированному SDK или самим агентом) формирует запрос `RetrieveKEMs` к **GLM**.
4.  **GLM**:
    *   Выполняет запрос (поиск по ID, векторный поиск, фильтрация по метаданным/датам).
    *   Возвращает запрошенные КЕПы в SWM.
5.  **SWM**:
    *   Получает КЕПы от GLM, сохраняет/обновляет их в своем внутреннем кэше.
    *   Возвращает запрошенные КЕПы в Agent SDK.
6.  **Agent SDK**:
    *   Получает КЕПы от SWM, сохраняет их в ЛПА.
    *   Передает КЕПы агенту.

### 4.3. Публикация знаний Агентом (через SWM и Agent SDK)

1.  **Агент** (через **Agent SDK**) формирует новую КЕП или данные для обновления существующей.
2.  **Agent SDK** вызывает метод `PublishKEMToSWM` у **SWM**, передавая КЕП и флаг `persist_to_glm_if_new_or_updated`.
3.  **SWM**:
    *   Присваивает/обновляет временные метки для КЕП в контексте SWM.
    *   Сохраняет/обновляет КЕП в своем внутреннем LRU-кэше.
    *   Если флаг `persist_to_glm_if_new_or_updated` установлен и есть GLM клиент:
        *   SWM вызывает метод `StoreKEM` у **GLM** для сохранения/обновления КЕП в долгосрочной памяти.
        *   При успешном сохранении в GLM, SWM может обновить КЕП в своем кэше на ту, что вернул GLM (для консистентности ID и серверных временных меток GLM).
    *   (В перспективе) Генерирует событие `KEM_PUBLISHED` или `KEM_UPDATED` для подписчиков.
4.  **SWM** возвращает ответ агенту о статусе публикации в SWM и (если применимо) о статусе операции с GLM.

## 5. Диаграмма Архитектуры (Текстовое представление)

```
+-------------------+     +---------------------+     +-------------------+
|      Агенты       |<--->|     Agent SDK       |<--->|        SWM        |
| (Пользователи КЕП)|     | (ЛПА, Клиенты S/G)  |     | (Кэш, Шина Памяти)|
+-------------------+     +---------------------+     +-------------------+
      ^       |                                           |      ^
      |       | (Подписка на события)                     |      | (Загрузка/Сохранение)
      |       +-------------------------------------------+      |
      | (Прямой доступ к GLM, если нужно обойти SWM)             |
      |                                                          |
      |               +---------------------+                    v
      +-------------->|         GLM         |<-------------------+
                      | (Qdrant, SQLite)  |
                      +---------------------+
                              ^
                              | (Сохранение КЕП)
                              |
                      +---------------------+
                      |         KPS         |
                      | (Обработка, Эмбед.) |
                      +---------------------+
                              ^
                              | (Сырые данные)
                      +-------------------+
                      |   Внешние Данные  |
                      +-------------------+
```
**Основные потоки:**
*   **Загрузка новых знаний:** Внешние Данные -> KPS -> GLM.
*   **Работа агента со знаниями (основной путь):** Агент <-> Agent SDK <-> SWM <-> GLM.
*   **Оповещение агентов об изменениях (в перспективе):** SWM -> (поток событий) -> Agent SDK -> Агент.

## 6. Будущие направления

*   **Полноценная реализация Pub/Sub в SWM:** Использование `asyncio` и очередей для каждого подписчика или интеграция с брокером сообщений (например, Redis Pub/Sub, Kafka, RabbitMQ) для надежной и масштабируемой рассылки событий `SubscribeToSWMEvents`.
*   **Более сложные политики кэширования и вытеснения в SWM:** Например, на основе частоты доступа, размера КЕП, или явного указания приоритета агентами.
*   **Улучшенная фильтрация в `QuerySWM`:** Поддержка более сложных запросов к данным в кэше, если это целесообразно без превращения SWM в полноценную БД.
*   **Реализация других сервисов:** Например, сервис для управления конфигурациями агентов, сервис аналитики использования памяти.
*   **Безопасность:** Добавление аутентификации (например, на основе токенов gRPC) и авторизации (гранулярные права доступа к КЕП и методам сервисов).
*   **Контейнеризация и развертывание:** Подготовка `Dockerfile` для каждого сервиса и примеров `docker-compose.yml` для упрощения локального развертывания и тестирования всей системы. Переход к Kubernetes для продакшн-среды.
*   **Комплексное интеграционное и нагрузочное тестирование.**
*   **Обработка ошибок и отказоустойчивость:** Более детальная проработка механизмов повторных попыток, отказоустойчивости при недоступности одного из сервисов.

EOF

echo "Файл архитектурной документации $ARCH_DOC_PATH создан."
echo "Содержимое (начало):"
head -n 40 "$ARCH_DOC_PATH"
echo "..."
echo "Содержимое (конец):"
tail -n 30 "$ARCH_DOC_PATH"
echo ""
echo "Шаг написания текста для архитектурного документа завершен."
