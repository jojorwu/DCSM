# Архитектура Системы ДКОП (Динамическая Контекстуализированная Общая Память)

## 1. Введение

Система Динамической Контекстуализированной Общей Памяти (ДКОП) предназначена для эффективного управления знаниями в сложных, потенциально многоагентных системах. Она расширяет идеи подходов Cache-Augmented Generation (CAG) и Retrieval-Augmented Generation (RAG), фокусируясь на динамическом, распределенном и контекстуализированном доступе к информации. Основная цель - предоставить агентам релевантные знания в нужный момент, оптимизируя при этом использование ресурсов и способствуя совместному накоплению знаний.

## 2. Основные Принципы ДКОП

*   **Контекстуализированные Единицы Памяти (КЕП):** Знание не является монолитным, а разбивается на семантически связные "Контекстуализированные Единицы Памяти". Каждая КЕП содержит не только сам контент, но и богатые метаданные (тема, источник, актуальность, права доступа, векторные эмбеддинги и т.д.), что позволяет более гранулированно и интеллектуально управлять знанием.
*   **Иерархическая Структура Памяти:** Система использует многоуровневую память для баланса между скоростью доступа и объемом хранимой информации:
    *   **Глобальная/Долгосрочная Память (GLM):** Персистентное хранилище всех КЕП.
    *   **Общая Рабочая Память (SWM):** Активный, кэширующий слой для "горячих" КЕП, с которым взаимодействуют агенты.
    *   **Локальная Память Агента (ЛПА):** Краткосрочный кэш на стороне агента (реализуется в Agent SDK) для наиболее часто используемых им КЕП.
*   **Общая Шина Памяти:** Концептуально реализована через SWM, позволяет агентам "подписываться" на релевантные КЕП или "публиковать" новые, обеспечивая масштабируемость и гибкость.
*   **Динамическая Предварительная Загрузка и Вытеснение:** SWM динамически управляет своим кэшем, загружая релевантные КЕП из GLM и вытесняя менее актуальные.
*   **Межагентный Обмен Памятью:** Облегчается через публикацию КЕП в SWM, откуда они становятся доступны другим агентам или могут быть сохранены в GLM.

## 3. Компоненты Системы

### 3.1. Общие определения Protobuf (`dcs_memory/common/grpc_protos/`)

*   **Роль:** Определяют контракты данных (сообщения) и сервисов (gRPC) для взаимодействия между всеми компонентами системы. Обеспечивают строгую типизацию и межъязыковую совместимость.
*   **Ключевые файлы:**
    *   `kem.proto`: Определение Контекстуализированной Единицы Памяти (КЕП) - базовой структуры данных.
    *   `glm_service.proto`: API для Сервиса Глобальной/Долгосрочной Памяти.
    *   `kps_service.proto`: API для Сервиса Обработки Знаний.
    *   `swm_service.proto`: API для Сервиса Общей Рабочей Памяти.

### 3.2. Сервис Глобальной/Долгосрочной Памяти (GLM)

*   **Расположение:** `dcs_memory/services/glm/`
*   **Назначение:** Надежное и масштабируемое персистентное хранилище для всех КЕП в системе.
*   **Основные функции:**
    *   Сохранение КЕП, включая их контент, метаданные и векторные эмбеддинги.
    *   Извлечение КЕП по их уникальным идентификаторам.
    *   Комплексные запросы к КЕП с использованием фильтрации по метаданным, диапазонам дат.
    *   Векторный поиск по эмбеддингам для нахождения семантически близких КЕП.
    *   Обновление и удаление существующих КЕП.
    *   **Обработка конфликтов при записи**: При сохранении КЕП (`StoreKEM`, `BatchStoreKEMs`) с уже существующим ID, данные перезаписываются (логика `INSERT OR REPLACE` в SQLite и `upsert` в Qdrant).
    *   **Пакетное сохранение и консистентность (`BatchStoreKEMs`)**: Метод `BatchStoreKEMs` пытается сохранить каждую КЕП из пакета. Если для какой-либо КЕП не удается сохранить эмбеддинги в Qdrant (при их наличии), то соответствующая запись для этой КЕП удаляется из SQLite для поддержания базовой консистентности между хранилищами метаданных и векторов.
*   **Технологии (текущая реализация):**
    *   gRPC для определения и предоставления API.
    *   Qdrant: используется как векторная база данных для хранения эмбеддингов и выполнения поиска по сходству.
    *   SQLite: используется для хранения структурированных метаданных и основного контента КЕП.
*   **API (gRPC - `glm_service.proto`):**
    *   `StoreKEM`: Сохраняет или обновляет одну КЕП. Генерирует ID, если не предоставлен.
    *   `RetrieveKEMs`: Извлекает КЕП по сложным критериям, включая фильтры, векторный запрос и пагинацию.
    *   `UpdateKEM`: Частично обновляет существующую КЕП по ее ID.
    *   `DeleteKEM`: Удаляет КЕП по ее ID.

### 3.3. Сервис Обработки Знаний (KPS)

*   **Расположение:** `dcs_memory/services/kps/`
*   **Назначение:** Точка входа для новых знаний в систему. Принимает сырые данные, обрабатывает их, генерирует эмбеддинги и формирует КЕП для последующего сохранения в GLM.
*   **Основные функции:**
    *   Прием сырых данных различных типов (например, текст, в перспективе другие форматы).
    *   Генерация векторных эмбеддингов для текстового контента с использованием моделей из библиотеки `sentence-transformers`.
    *   Формирование объектов КЕП, включая извлечение или получение `content_type`, `raw_content`, `initial_metadata` и добавление сгенерированных `embeddings`.
    *   Взаимодействие с GLM (через его gRPC клиент) для сохранения созданных КЕП.
*   **Технологии (текущая реализация):**
    *   gRPC для API.
    *   `sentence-transformers`: для генерации эмбеддингов.
    *   GLM gRPC клиент (с встроенным механизмом повторных попыток `@retry_grpc_call` для повышения отказоустойчивости при взаимодействии с GLM).
*   **API (gRPC - `kps_service.proto`):**
    *   `ProcessRawData`: Принимает сырые данные и метаданные, обрабатывает их и инициирует сохранение в GLM. Возвращает ID сохраненной КЕП и статус операции.

### 3.4. Сервис Общей Рабочей Памяти (SWM)

*   **Расположение:** `dcs_memory/services/swm/`
*   **Назначение:** Выступает в роли активного, быстрого кэширующего слоя памяти на базе Redis, с которым непосредственно взаимодействуют агенты. Управляет "горячими" КЕП, обеспечивает коллективный доступ и координацию.
*   **Основные функции:**
    *   **Кэширование активных КЕП в Redis:** Использует Redis для хранения КЕП. КЕП хранятся как Redis Hashes. Поддерживаются вторичные индексы по настраиваемым полям метаданных (через Redis Sets) и по датам создания/обновления (через Redis Sorted Sets).
    *   **Политика вытеснения LRU:** Реализуется через конфигурацию Redis (`maxmemory` и `maxmemory-policy allkeys-lru`).
    *   **Загрузка из GLM:** По запросу (`LoadKEMsFromGLM`) извлекает КЕП из GLM и помещает их в кэш Redis.
    *   **Запрос из кэша:** Предоставляет агентам интерфейс (`QuerySWM`) для запроса КЕП из кэша Redis с фильтрацией по ID, индексируемым метаданным и датам. Сортировка по умолчанию по дате обновления.
    *   **Публикация КЕП:** Агенты могут публиковать КЕП в SWM (`PublishKEMToSWM`). КЕП сохраняются в кэше Redis. Если указан флаг персистенции, КЕП помещается в очередь для асинхронной пакетной записи в GLM.
    *   **Подписка на события:** Метод `SubscribeToSWMEvents` позволяет агентам подписываться на события создания (`KEM_PUBLISHED`), обновления (`KEM_UPDATED`) и вытеснения (`KEM_EVICTED`) КЕП в SWM. Поддерживается фильтрация по ID, метаданным и типу события. События `KEM_EVICTED` генерируются на основе Redis Keyspace Notifications.
    *   **Управление распределенными блокировками и счетчиками:** Предоставляет механизмы для координации агентов (логика инкапсулирована в соответствующих менеджерах).
*   **Стратегии кэширования и вытеснения в SWM**:
    *   **Хранилище**: Redis. КЕП хранятся как Redis Hashes. Вторичные индексы для метаданных (по ключам, указанным в `SWM_INDEXED_METADATA_KEYS`) и для дат `created_at`/`updated_at` поддерживаются с использованием Redis Sets и Sorted Sets соответственно.
    *   **Вытеснение**: Управляется Redis на основе политики `allkeys-lru` и настройки `maxmemory`.
    *   **Уведомление о вытеснении**: SWM подписывается на Redis Keyspace Notifications (`__keyevent@<db>__:evicted`). При получении уведомления генерируется событие `KEM_EVICTED` (содержащее только ID КЕП) для подписчиков SWM.
*   **Синхронизация SWM с GLM**:
    *   **Загрузка из GLM (`LoadKEMsFromGLM`)**: SWM загружает КЕП из GLM и помещает их в кэш Redis. Если КЕП с таким ID уже была в кэше, она обновляется. Генерируются события `KEM_PUBLISHED` или `KEM_UPDATED`.
    *   **Сохранение в GLM (`PublishKEMToSWM`)**: При публикации КЕП в SWM с флагом `persist_to_glm_if_new_or_updated`, КЕП помещается во внутреннюю очередь. Фоновый воркер (`_glm_persistence_worker`) обрабатывает эту очередь, формируя батчи и отправляя их в GLM через `BatchStoreKEMs`. После успешного сохранения в GLM, кэш SWM обновляется версией КЕП из ответа GLM (для консистентности ID и временных меток).
*   **Технологии (текущая реализация):**
    *   gRPC для API.
    *   Redis: для основного кэша КЕП и вторичных индексов. Используется клиент `aioredis`.
    *   GLM gRPC клиент (асинхронный, с retry-логикой).
    *   Внутренние `asyncio.Queue` для Pub/Sub механизма SWM и для очереди персистенции в GLM.
*   **API (gRPC - `swm_service.proto`):**
    *   `PublishKEMToSWM`: Публикация КЕП в SWM (Redis). Опционально ставит в очередь на асинхронную персистенцию в GLM.
    *   `SubscribeToSWMEvents`: Подписка на события SWM.
    *   `QuerySWM`: Запрос КЕП из кэша SWM (Redis) с фильтрацией.
    *   `LoadKEMsFromGLM`: Инициирование загрузки КЕП из GLM в кэш SWM (Redis).
    *   `AcquireLock`, `ReleaseLock`, `GetLockInfo`: Управление распределенными блокировками.
    *   `IncrementCounter`, `GetCounter`: Работа с распределенными счетчиками.

### 3.5. Agent SDK (`dcsm_agent_sdk_python`)

*   **Расположение:** `dcsm_agent_sdk_python/` (разрабатывался как отдельный пакет)
*   **Назначение:** Предоставление удобного Python-интерфейса для агентов для взаимодействия с сервисами ДКОП (GLM, SWM, KPS).
*   **Основные функции (реализовано для GLM, частично для SWM в перспективе):**
    *   Клиент для GLM (`GLMClient`) для прямого взаимодействия с долгосрочной памятью (включает retry-логику).
    *   Локальная Память Агента (`LocalAgentMemory`):
        *   Реализована на базе `IndexedLRUCache` (см. раздел 3.6), обеспечивая LRU-вытеснение и возможность индексации по метаданным.
        *   Хранит КЕП в виде Python-словарей.
        *   Индексируемые ключи настраиваются при инициализации `AgentSDK(lpa_indexed_keys=...)`.
        *   Позволяет выполнять локальные запросы к кэшу через `AgentSDK.query_local_memory()`.
    *   Высокоуровневые методы в `AgentSDK` (`get_kem`, `store_kems`, `update_kem`, `delete_kem`):
        *   **`get_kem(kem_id, force_remote)`**:
            *   Сначала проверяет наличие КЕП в ЛПА. Если найдена и `force_remote=False`, возвращает ее.
            *   В противном случае, обращается к GLM для получения КЕП.
            *   Полученная от GLM КЕП сохраняется/обновляется в ЛПА перед возвратом агенту.
        *   **`store_kems(kems_data)`**:
            *   Отправляет пакет КЕП на сохранение в GLM.
            *   Все успешно сохраненные/обновленные КЕП (возвращенные GLM с серверными ID и временными метками) помещаются/обновляются в ЛПА.
        *   **`update_kem(kem_id, kem_data_update)`**:
            *   Отправляет запрос на обновление КЕП в GLM.
            *   Обновленная КЕП, возвращенная GLM, помещается/обновляется в ЛПА.
        *   **`delete_kem(kem_id)`**:
            *   Отправляет запрос на удаление КЕП в GLM.
            *   В случае успеха, КЕП также удаляется из ЛПА.
        *   Таким образом, ЛПА стремится поддерживать актуальность кэшированных данных относительно тех операций, которые сам агент выполняет через SDK. Автоматической синхронизации ЛПА с изменениями, сделанными другими агентами или напрямую в GLM/SWM, не происходит (для этого агенту нужно было бы использовать механизм подписок SWM).
    *   **Взаимодействие с SWM**:
        *   Предоставляет методы для пакетной публикации КЕП в SWM (`publish_kems_to_swm_batch`) и загрузки КЕП из SWM в ЛПА (`load_kems_to_lpa_from_swm`).
        *   Реализует утилиты для подписки на события SWM (`handle_swm_events`), включая возможность автоматического обновления ЛПА на основе этих событий.
        *   Предоставляет высокоуровневые методы для работы с распределенными блокировками (`acquire_distributed_lock`, `release_distributed_lock`, `get_distributed_lock_info`) и контекстный менеджер `distributed_lock` для удобного управления блокировками.
        *   Включает методы для работы с распределенными счетчиками SWM (`increment_distributed_counter`, `get_distributed_counter`).
    *   В перспективе: клиенты для KPS, более сложные утилиты координации для многоагентных систем.

## 4. Взаимодействие Компонентов и Потоки Данных

### 4.1. Добавление новых знаний в систему (через KPS)

1.  **Инициатор** (например, внешний процесс, другой сервис, или агент через спец. интерфейс) отправляет сырые данные (текст, файл и т.д.) и начальные метаданные в **KPS** через его метод `ProcessRawData`.
2.  **KPS**:
    *   Декодирует контент, если это текст.
    *   Генерирует векторные эмбеддинги для текстового контента с помощью `sentence-transformers`.
    *   Формирует объект `KEM`, заполняя `content`, `content_type`, `embeddings`, `initial_metadata`.
    *   Вызывает метод `StoreKEM` у **GLM**, передавая сформированную КЕП (без ID, GLM его сгенерирует).
3.  **GLM**:
    *   Генерирует уникальный ID для КЕП.
    *   Устанавливает временные метки `created_at`, `updated_at`.
    *   Сохраняет эмбеддинги и ассоциированный payload в Qdrant (см. ниже описание структуры точки Qdrant).
    *   Сохраняет остальные данные КЕП в SQLite (см. ниже описание таблицы `kems`).
    *   Возвращает полную сохраненную КЕП (с ID и временными метками) обратно в KPS.
4.  **KPS** получает ответ от GLM и возвращает `kem_id` и статус операции инициатору запроса.

#### 4.1.1. Структура данных в GLM

##### Таблица `kems` в SQLite (GLM)

*   **Назначение**: Хранение основного контента и метаданных КЕП.
*   **Структура**:
    *   `id TEXT PRIMARY KEY`: Уникальный идентификатор КЕП (UUID).
    *   `content_type TEXT`: MIME-тип содержимого (например, "text/plain", "application/json").
    *   `content BLOB`: Основное содержимое КЕП в виде бинарных данных. Текстовые данные кодируются в UTF-8 перед сохранением.
    *   `metadata TEXT`: Метаданные КЕП, хранящиеся в виде JSON-строки. Пример: `{"source": "doc.pdf", "topic": "AI"}`.
    *   `created_at TEXT`: Дата и время создания КЕП в формате ISO 8601 (например, "YYYY-MM-DDTHH:MM:SS.ffffff"). Устанавливается при первом сохранении.
    *   `updated_at TEXT`: Дата и время последнего обновления КЕП в формате ISO 8601. Обновляется при каждом сохранении/изменении.
*   **Индексы**:
    *   `PRIMARY KEY` на `id`.
    *   Индекс на `created_at`.
    *   Индекс на `updated_at`.
*   **PRAGMA-настройки (применяются при каждом соединении)**:
    *   `PRAGMA journal_mode=WAL;`: Режим Write-Ahead Logging для улучшения параллелизма и производительности записи.
    *   `PRAGMA synchronous=NORMAL;`: Ускоряет операции записи (с небольшим риском потери данных при сбое питания системы).
    *   `PRAGMA foreign_keys=ON;`: Включает поддержку внешних ключей (хотя в текущей схеме они не используются, это хорошая практика).
    *   `PRAGMA busy_timeout = 7500;`: Устанавливает таймаут (в миллисекундах) для операций, ожидающих снятия блокировки базы данных.

##### Структура точки в Qdrant (GLM)

*   **Назначение**: Хранение векторных эмбеддингов для семантического поиска и фильтруемых атрибутов.
*   **ID точки**: Соответствует `id` КЕП из SQLite.
*   **Вектор**: Массив чисел с плавающей точкой (float), представляющий эмбеддинг контента КЕП. Размерность вектора определяется конфигурацией (`DEFAULT_VECTOR_SIZE`). Используемая метрика расстояния – Косинусное сходство (`Cosine`).
*   **Payload (полезная нагрузка)**: JSON-объект, содержащий следующие поля для фильтрации и связи с SQLite:
    *   `kem_id_ref: string`: Копия ID КЕП (для удобства).
    *   `md_<key>: string | number | boolean`: Поля из `metadata` КЕП. Каждый ключ из словаря `metadata` КЕП сохраняется с префиксом `md_`. Например, если в `metadata` есть `{"source": "web"}`, то в payload Qdrant будет поле `md_source: "web"`. Это позволяет Qdrant индексировать и фильтровать по этим полям.
    *   `created_at_ts: integer`: Временная метка создания КЕП в формате Unix timestamp (количество секунд с начала эпохи). Используется для фильтрации по диапазонам дат в Qdrant.
    *   `updated_at_ts: integer`: Временная метка последнего обновления КЕП в формате Unix timestamp. Используется для фильтрации по диапазонам дат в Qdrant.

### 4.2. Получение знаний Агентом (через SWM и Agent SDK)

1.  **Агент** (через **Agent SDK**) запрашивает КЕП.
2.  **Agent SDK**:
    *   Сначала проверяет свою Локальную Память Агента (ЛПА). Если КЕП найдена, возвращает ее.
    *   Если в ЛПА нет, SDK обращается к **SWM** с запросом `QuerySWM`.
3.  **SWM**:
    *   Ищет КЕП в своем внутреннем кэше по критериям из `QuerySWM`.
    *   Если КЕП найдена в кэше, SWM возвращает ее в Agent SDK.
    *   Если КЕП не найдена в кэше, SWM (по запросу `LoadKEMsFromGLM`, инициированному SDK или самим агентом) формирует запрос `RetrieveKEMs` к **GLM**.
4.  **GLM**:
    *   Выполняет запрос (поиск по ID, векторный поиск, фильтрация по метаданным/датам).
    *   Возвращает запрошенные КЕПы в SWM.
5.  **SWM**:
    *   Получает КЕПы от GLM, сохраняет/обновляет их в своем внутреннем кэше.
    *   Возвращает запрошенные КЕПы в Agent SDK.
6.  **Agent SDK**:
    *   Получает КЕПы от SWM, сохраняет их в ЛПА.
    *   Передает КЕПы агенту.

### 4.3. Публикация знаний Агентом (через SWM и Agent SDK)

1.  **Агент** (через **Agent SDK**) формирует новую КЕП или данные для обновления существующей.
2.  **Agent SDK** вызывает метод `PublishKEMToSWM` у **SWM**, передавая КЕП и флаг `persist_to_glm_if_new_or_updated`.
3.  **SWM**:
    *   Присваивает/обновляет временные метки для КЕП в контексте SWM.
    *   Сохраняет/обновляет КЕП в своем внутреннем LRU-кэше.
    *   Если флаг `persist_to_glm_if_new_or_updated` установлен и есть GLM клиент:
        *   SWM вызывает метод `StoreKEM` у **GLM** для сохранения/обновления КЕП в долгосрочной памяти.
        *   При успешном сохранении в GLM, SWM может обновить КЕП в своем кэше на ту, что вернул GLM (для консистентности ID и серверных временных меток GLM).
    *   (В перспективе) Генерирует событие `KEM_PUBLISHED` или `KEM_UPDATED` для подписчиков.
4.  **SWM** возвращает ответ агенту о статусе публикации в SWM и (если применимо) о статусе операции с GLM.

#### 4.3.1. Структура данных в SWM (Кэш на базе Redis)

*   **Назначение**: Быстрое хранение "горячих" КЕП для оперативного доступа агентами, способное работать с большими объемами данных.
*   **Хранилище**: Redis.
*   **Хранение КЕП**:
    *   **Ключ основного объекта КЕП:** `swm_kem:<kem_id>` (например, `swm_kem:a1b2c3d4-e5f6-7890-1234-567890abcdef`).
    *   **Тип данных Redis:** Hash.
    *   **Поля хэша для КЕП:**
        *   `id`: (строка) `<kem_id_str>`
        *   `content_type`: (строка) `<mime_type_kem>`
        *   `content`: (байтовая строка) Сериализованное содержимое КЕП (protobuf `kem.content`).
        *   `metadata`: (строка) JSON-строка всех метаданных КЕП.
        *   `created_at`: (строка) ISO 8601 строка временной метки создания.
        *   `updated_at`: (строка) ISO 8601 строка временной метки обновления.
        *   `created_at_ts`: (число-строка) Unix timestamp (секунды) для `created_at` (используется для сортировки/фильтрации в Redis).
        *   `updated_at_ts`: (число-строка) Unix timestamp (секунды) для `updated_at` (используется для сортировки/фильтрации в Redis).
        *   `embeddings`: (байтовая строка) Сериализованный список float-чисел (например, через MessagePack).
*   **Вторичная индексация (ручная, без RediSearch):**
    *   **Индексы по метаданным:**
        *   **Тип данных Redis:** Set.
        *   **Ключ индекса:** `swm_idx:meta:<ключ_метаданных>:<значение_метаданных>` (например, `swm_idx:meta:type:document`).
        *   **Члены множества:** ID КЕП (`<kem_id>`).
        *   Обновляются атомарно при операциях set/delete КЕП с использованием транзакций `MULTI/EXEC`.
    *   **Индексы по датам:**
        *   **Тип данных Redis:** Sorted Set.
        *   **Ключи индексов:** `swm_idx:date:created_at` и `swm_idx:date:updated_at`.
        *   **Score:** Unix timestamp (целое число, секунды).
        *   **Member:** ID КЕП (`<kem_id>`).
        *   Обновляются атомарно при операциях set/delete КЕП.
*   **Политика вытеснения LRU:**
    *   Настраивается в Redis: `maxmemory <размер>` и `maxmemory-policy allkeys-lru`.
*   **Уведомления о вытеснении:**
    *   SWM подписывается на Redis Keyspace Notifications (`__keyevent@<db>__:evicted`). Событие `KEM_EVICTED` в SWM содержит только ID вытесненного КЕП.

#### 4.3.2. Структура данных в ЛПА (Локальная Память Агента в Agent SDK)

*   **Назначение**: Кэширование наиболее часто используемых агентом КЕП на стороне клиента для минимизации задержек и сетевого трафика.
*   **Хранилище**: `IndexedLRUCache` (аналогично SWM, но работает в адресном пространстве агента).
*   **Формат КЕП**: КЕП хранятся в ЛПА как Python-словари (`dict`). Эти словари являются результатом преобразования proto-сообщений `KEM`, полученных от GLM или SWM.
    *   Структура словаря точно соответствует полям proto-сообщения `KEM` (например, `kem_dict['id']`, `kem_dict['content_type']`, `kem_dict['metadata']` (который сам является словарем), `kem_dict['embeddings']` (список float), `kem_dict['created_at']` (строка ISO 8601), `kem_dict['updated_at']` (строка ISO 8601)).
*   **Индексация**:
    *   Как и в SWM, `IndexedLRUCache` в ЛПА может индексировать КЕП по значениям заданных ключей метаданных. Список индексируемых ключей передается при инициализации `AgentSDK(lpa_indexed_keys=["key1", "key2"])`.
    *   Метод `AgentSDK.query_local_memory()` использует эти индексы для быстрой фильтрации КЕП в ЛПА.

## 5. Диаграмма Архитектуры (Текстовое представление)

```
+-------------------+     +---------------------+     +-------------------+
|      Агенты       |<--->|     Agent SDK       |<--->|        SWM        |
| (Пользователи КЕП)|     | (ЛПА, Клиенты S/G)  |     | (Кэш, Шина Памяти)|
+-------------------+     +---------------------+     +-------------------+
      ^       |                                           |      ^
      |       | (Подписка на события)                     |      | (Загрузка/Сохранение)
      |       +-------------------------------------------+      |
      | (Прямой доступ к GLM, если нужно обойти SWM)             |
      |                                                          |
      |               +---------------------+                    v
      +-------------->|         GLM         |<-------------------+
                      | (Qdrant, SQLite)  |
                      +---------------------+
                              ^
                              | (Сохранение КЕП)
                              |
                      +---------------------+
                      |         KPS         |
                      | (Обработка, Эмбед.) |
                      +---------------------+
                              ^
                              | (Сырые данные)
                      +-------------------+
                      |   Внешние Данные  |
                      +-------------------+
```
**Основные потоки:**
*   **Загрузка новых знаний:** Внешние Данные -> KPS -> GLM.
*   **Работа агента со знаниями (основной путь):** Агент <-> Agent SDK <-> SWM <-> GLM.
*   **Оповещение агентов об изменениях (в перспективе):** SWM -> (поток событий) -> Agent SDK -> Агент.

## 6. Будущие направления

*   **Полноценная реализация Pub/Sub в SWM:** Использование `asyncio` и очередей для каждого подписчика или интеграция с брокером сообщений (например, Redis Pub/Sub, Kafka, RabbitMQ) для надежной и масштабируемой рассылки событий `SubscribeToSWMEvents`.
*   **Более сложные политики кэширования и вытеснения в SWM:** Например, на основе частоты доступа, размера КЕП, или явного указания приоритета агентами.
*   **Улучшенная фильтрация в `QuerySWM`:** Поддержка более сложных запросов к данным в кэше, если это целесообразно без превращения SWM в полноценную БД.
*   **Реализация других сервисов:** Например, сервис для управления конфигурациями агентов, сервис аналитики использования памяти.
*   **Безопасность:** Добавление аутентификации (например, на основе токенов gRPC) и авторизации (гранулярные права доступа к КЕП и методам сервисов).
*   **Контейнеризация и развертывание:** Подготовка `Dockerfile` для каждого сервиса и примеров `docker-compose.yml` для упрощения локального развертывания и тестирования всей системы. Переход к Kubernetes для продакшн-среды.
*   **Комплексное интеграционное и нагрузочное тестирование.**
    *   **Обработка ошибок и отказоустойчивость (текущее состояние и развитие):**
        *   **Текущее состояние**:
            *   Клиенты GLM (в KPS, SWM, AgentSDK) используют механизм повторных попыток (`@retry_grpc_call`) при gRPC-вызовах к GLM, что помогает справляться с кратковременными сетевыми проблемами или перезапусками GLM.
            *   GLM сервис имеет базовую логику (`BatchStoreKEMs`) для поддержания консистентности между SQLite и Qdrant при пакетной вставке (если эмбеддинги не сохранились в Qdrant, запись удаляется из SQLite).
            *   GLM сервис не запускается, если Qdrant недоступен при старте. KPS и SWM логируют предупреждения, если GLM недоступен при их старте, но могут продолжить работу с ограниченной функциональностью (например, SWM без возможности персистенции или загрузки из GLM).
        *   **Направления развития**:
            *   Более гранулярная обработка ошибок и стратегии отката для сложных операций, включающих несколько сервисов.
            *   Реализация механизмов "circuit breaker" для предотвращения каскадных сбоев.
            *   Улучшение логики поведения сервисов при длительной недоступности критических зависимостей (например, стратегии очередей для отложенной обработки).
            *   Введение health check эндпоинтов для всех gRPC сервисов для интеграции с системами оркестрации.

### 3.6. Механизм `IndexedLRUCache`

Компоненты SWM и Agent SDK (для ЛПА) используют кастомную реализацию кэша под названием `IndexedLRUCache`. Этот кэш расширяет стандартную LRU (Least Recently Used) логику, добавляя возможность индексирования хранимых объектов по значениям их метаданных для ускорения выборочных запросов.

**Основные характеристики и логика работы:**

1.  **LRU-Стратегия Вытеснения**:
    *   В основе `IndexedLRUCache` лежит `cachetools.LRUCache`. Когда кэш достигает своего максимального размера (`maxsize`), при добавлении нового элемента самый давно неиспользованный элемент автоматически вытесняется.
    *   Любая операция доступа к элементу (чтение `get` или обновление `__setitem__`) делает этот элемент "недавно использованным", отодвигая его вытеснение.

2.  **Индексация по Метаданным**:
    *   При инициализации `IndexedLRUCache` (например, в SWM или ЛПА) можно указать список ключей метаданных (`indexed_keys`), по которым будет производиться индексация.
    *   Для каждого такого ключа кэш создает внутренний обратный индекс (словарь), где каждому значению этого ключа метаданных соответствует множество (`set`) ID КЕП, у которых данный ключ метаданных имеет это значение.
    *   **Пример**: Если `indexed_keys = ["topic", "source"]`, и в кэш добавляется КЕП с `id="kem1"` и `metadata={"topic": "AI", "source": "doc.pdf"}`, то:
        *   В индексе для `topic` по ключу `"AI"` добавится `"kem1"`.
        *   В индексе для `source` по ключу `"doc.pdf"` добавится `"kem1"`.
    *   Индексируются только строковые значения метаданных.

3.  **Обновление Индексов**:
    *   **Добавление/Обновление КЕП (`__setitem__`)**:
        *   Если КЕП обновляется, сначала ее старые значения метаданных удаляются из индексов.
        *   Затем новые (или текущие) значения индексируемых метаданных добавляются в индексы.
        *   После этого КЕП помещается (или обновляется) в основной LRU-кэш.
    *   **Удаление КЕП (`__delitem__`, `pop`)**: При удалении КЕП из кэша, соответствующие записи также удаляются из всех метаданных-индексов.
    *   **Вытеснение**: Когда элемент вытесняется по LRU-логике, он также удаляется из метаданных-индексов. В SWM для этого используется колбэк `on_evict_callback`.

4.  **Использование Индексов при Запросах**:
    *   Методы `QuerySWM` (в SWM) и `LocalAgentMemory.query()` (в Agent SDK) используют эти индексы для ускорения фильтрации.
    *   Если запрос содержит фильтры по индексируемым ключам метаданных, кэш сначала получает наборы ID КЕП из соответствующих индексов.
    *   Затем эти наборы ID пересекаются (если фильтров по индексируемым ключам несколько) для получения списка ID КЕП, удовлетворяющих всем индексным условиям.
    *   Только после этого из основного LRU-хранилища извлекаются полные объекты КЕП по этим ID для дальнейшей неиндексированной фильтрации (если она есть) и возврата результата.
    *   Это значительно эффективнее, чем полный перебор всех элементов кэша для каждого запроса с фильтрацией.

5.  **Потокобезопасность**:
    *   Все операции с `IndexedLRUCache` (добавление, удаление, чтение, обновление индексов) защищены с помощью `threading.Lock`. Это обеспечивает корректную работу в многопоточной среде сервисов SWM и потенциально в многопоточных агентах, использующих ЛПА.

6.  **Хранимые Данные**:
    *   В SWM `IndexedLRUCache` хранит непосредственно proto-сообщения `kem_pb2.KEM`.
    *   В ЛПА (Agent SDK) `IndexedLRUCache` хранит КЕП в виде Python-словарей. Логика индексации адаптирована для работы со словарями.

`IndexedLRUCache` представляет собой компромисс между скоростью доступа, потреблением памяти под индексы и сложностью реализации, позволяя эффективно работать с кэшированными данными в оперативной памяти.

## 7. Примеры использования API (gRPC)

Этот раздел демонстрирует примеры формирования запросов к основным сервисам системы. Примеры представлены в виде концептуальных структур, близких к тому, как они выглядели бы при использовании gRPC-клиента на Python.

### 7.1. GLM (GlobalLongTermMemory)

#### 7.1.1. `RetrieveKEMs`: Векторный поиск с фильтрацией

**Сценарий**: Найти до 10 КЕП, семантически близких к заданному тексту, но только те, которые были созданы после определенной даты и имеют метаданные `source="manual"` и `topic="AI"`.

```python
# Примерный Python-код для формирования запроса
import kem_pb2
import glm_service_pb2
from google.protobuf.timestamp_pb2 import Timestamp

# 1. KEMQuery
kem_query = glm_service_pb2.KEMQuery()

# Векторный запрос (предполагается, что text_query будет преобразован в embedding_query сервисом KPS или другим компонентом,
# либо клиент сам предоставляет эмбеддинг)
# Здесь для примера укажем embedding_query напрямую
kem_query.embedding_query.extend([0.1, 0.2, ..., 0.N]) # Заменить на реальный вектор нужной размерности

# Фильтры по метаданным (транслируются в Qdrant payload filter: "md_source" и "md_topic")
kem_query.metadata_filters["source"] = "manual"
kem_query.metadata_filters["topic"] = "AI"

# Фильтр по дате создания (транслируется в Qdrant payload filter: "created_at_ts")
created_after_ts = Timestamp()
created_after_ts.FromDatetime(datetime(2023, 1, 1, 0, 0, 0)) # Пример даты
kem_query.created_at_start.CopyFrom(created_after_ts)

# 2. RetrieveKEMsRequest
retrieve_request = glm_service_pb2.RetrieveKEMsRequest(
    query=kem_query,
    page_size=10
)

# Ожидаемое поведение GLM:
# 1. Строит фильтр для Qdrant на основе metadata_filters и created_at_start.
#    Фильтр будет примерно таким:
#    Filter(must=[
#        FieldCondition(key="md_source", match=MatchValue(value="manual")),
#        FieldCondition(key="md_topic", match=MatchValue(value="AI")),
#        FieldCondition(key="created_at_ts", range=Range(gte=1672531200)) # 1672531200 - это Unix timestamp для 2023-01-01
#    ])
# 2. Выполняет векторный поиск в Qdrant с этим фильтром и embedding_query.
# 3. Извлекает полные данные КЕП из SQLite для ID, полученных от Qdrant.
# 4. Возвращает список КЕП.
```

### 7.2. SWM (SharedWorkingMemoryService)

#### 7.2.1. `QuerySWM`: Запрос из кэша с комплексной фильтрацией

**Сценарий**: Найти в кэше SWM до 5 КЕП, которые имеют `id` из списка `["id1", "id2", "id3"]`, ИЛИ у которых метаданные `category="urgent"` (предполагаем, что `category` индексируется в SWM), И которые были обновлены в течение последнего часа.

```python
# Примерный Python-код для формирования запроса
import kem_pb2
import glm_service_pb2 # KEMQuery используется и для SWM
import swm_service_pb2
from google.protobuf.timestamp_pb2 import Timestamp
from datetime import datetime, timedelta

# 1. KEMQuery для SWM
# SWM не поддерживает embedding_query или text_query для своего кэша.
swm_kem_query = glm_service_pb2.KEMQuery()

# Фильтр по ID (если указаны, SWM сначала отберет по ним)
swm_kem_query.ids.extend(["id1", "id2", "id3"])

# Фильтр по метаданным (предположим, "category" индексируется в SWM)
swm_kem_query.metadata_filters["category"] = "urgent"
# Если "category" не индексируется, SWM выполнит полный перебор (после фильтрации по ID, если она была).

# Фильтр по дате обновления (за последний час)
one_hour_ago_ts = Timestamp()
one_hour_ago_ts.FromDatetime(datetime.utcnow() - timedelta(hours=1))
swm_kem_query.updated_at_start.CopyFrom(one_hour_ago_ts)

# 2. QuerySWMRequest
query_swm_request = swm_service_pb2.QuerySWMRequest(
    query=swm_kem_query,
    page_size=5
)

# Ожидаемое поведение SWM:
# 1. Если есть query.ids, отфильтрует КЕПы по этим ID.
# 2. Если есть фильтры по индексируемым метаданным (например, "category"), применит их.
#    Если были и ID, и индексные фильтры, результаты могут быть объединены или пересечены в зависимости от логики SWM.
#    (Текущая реализация QuerySWM сначала применяет индексные фильтры, затем фильтр по ID к результатам индексных).
#    Более логично было бы:
#    - Если есть IDs: взять КЕП по этим ID.
#    - К результату применить фильтры по метаданным (сначала индексные, потом неиндексные).
#    - К результату применить фильтры по датам.
#    Либо, если IDs и metadata_filters должны работать как OR - это усложняет запрос.
#    Proto не определяет логику И/ИЛИ между ids и metadata_filters.
#    Текущая реализация QuerySWM в main.py:
#    а) применяет индексные фильтры (если есть)
#    б) к результату (или ко всему кэшу, если индексных не было) применяет фильтр по query.ids (если есть)
#    в) к результату применяет неиндексные фильтры
#    г) к результату применяет фильтры по датам.
#    Этот пример будет работать согласно этой логике.
```

#### 7.2.2. `SubscribeToSWMEvents`: Подписка на конкретные события

**Сценарий**: Агент хочет получать уведомления о всех КЕП, у которых метаданные `project_id="project_alpha"`, а также обо всех изменениях КЕП с `id="important_kem_id"`.

```python
# Примерный Python-код для формирования запроса
import swm_service_pb2

subscribe_request = swm_service_pb2.SubscribeToSWMEventsRequest(
    agent_id="my_smart_agent_007"
)

# Топик 1: КЕПы по project_id
topic1 = swm_service_pb2.SubscriptionTopic(
    type=swm_service_pb2.SubscriptionTopic.TopicType.KEM_LIFECYCLE_EVENTS, # Общий тип событий
    filter_criteria="metadata.project_id=project_alpha" # Фильтр
)
subscribe_request.topics.append(topic1)

# Топик 2: Конкретная КЕП по ID
topic2 = swm_service_pb2.SubscriptionTopic(
    type=swm_service_pb2.SubscriptionTopic.TopicType.KEM_LIFECYCLE_EVENTS,
    filter_criteria="kem_id=important_kem_id"
)
subscribe_request.topics.append(topic2)

# Ожидаемое поведение SWM:
# Агент будет получать события (KEM_PUBLISHED, KEM_UPDATED, KEM_EVICTED)
# для КЕП, удовлетворяющих хотя бы одному из filter_criteria.
# Например, если опубликована КЕП с metadata={"project_id":"project_alpha", "other":"data"}, агент получит событие.
# Если обновлена КЕП с id="important_kem_id", агент получит событие.
```

Эти примеры иллюстрируют, как можно формировать более сложные запросы к API системы. Реальная работа с gRPC клиентами потребует соответствующей настройки каналов и вызова методов стаба.

EOF

echo "Файл архитектурной документации $ARCH_DOC_PATH создан."
echo "Содержимое (начало):"
head -n 40 "$ARCH_DOC_PATH"
echo "..."
echo "Содержимое (конец):"
tail -n 30 "$ARCH_DOC_PATH"
echo ""
echo "Шаг написания текста для архитектурного документа завершен."
