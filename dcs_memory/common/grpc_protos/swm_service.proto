syntax = "proto3";

package dcsm;

import "kem.proto";
import "glm_service.proto"; // Для KEMQuery, если мы его переиспользуем
import "google/protobuf/timestamp.proto";

option go_package = "github.com/your_org/dcsm_protos/gen/go/swm;swm_service_pb";

// Сервис Общей Рабочей Памяти (Shared Working Memory Service)
service SharedWorkingMemoryService {
  // Публикует КЕП в SWM. Может также инициировать сохранение/обновление в GLM.
  rpc PublishKEMToSWM(PublishKEMToSWMRequest) returns (PublishKEMToSWMResponse);

  // Подписывается на события, происходящие в SWM (например, появление новых КЕП).
  rpc SubscribeToSWMEvents(SubscribeToSWMEventsRequest) returns (stream SWMMemoryEvent);

  // Запрашивает активные КЕП непосредственно из SWM (из ее кэша).
  rpc QuerySWM(QuerySWMRequest) returns (QuerySWMResponse);

  // Запрашивает загрузку КЕП из GLM в SWM (в кэш SWM).
  rpc LoadKEMsFromGLM(LoadKEMsFromGLMRequest) returns (LoadKEMsFromGLMResponse);

  // --- RPC для управления блокировками ---
  // Пытается получить блокировку на ресурс.
  rpc AcquireLock(AcquireLockRequest) returns (AcquireLockResponse);
  // Освобождает ранее полученную блокировку.
  rpc ReleaseLock(ReleaseLockRequest) returns (ReleaseLockResponse);
  // Получает информацию о текущем состоянии блокировки для ресурса.
  rpc GetLockInfo(GetLockInfoRequest) returns (LockInfo);

  // --- RPC для распределенных счетчиков ---
  // Атомарно инкрементирует (или декрементирует) значение счетчика.
  // Если счетчик не существует, он создается со значением increment_by.
  rpc IncrementCounter(IncrementCounterRequest) returns (CounterValueResponse);
  // Получает текущее значение счетчика.
  // Если счетчик не существует, может вернуть ошибку или значение по умолчанию (например, 0).
  rpc GetCounter(DistributedCounterRequest) returns (CounterValueResponse);
  // TODO: Добавить DeleteCounter(DistributedCounterRequest) returns (google.protobuf.Empty) в будущем.
}

// --- Сообщения для PublishKEMToSWM ---
message PublishKEMToSWMRequest {
  KEM kem_to_publish = 1;
  bool persist_to_glm_if_new_or_updated = 2; // Если true, SWM попытается сохранить/обновить КЕП в GLM
}

message PublishKEMToSWMResponse {
  string kem_id = 1; // ID опубликованной КЕП (может быть сгенерирован GLM, если persist_to_glm=true и ID не было)
  bool published_to_swm = 2; // Успешно ли опубликовано в кэше SWM
  bool persistence_triggered_to_glm = 3; // Был ли инициирован вызов к GLM
  string status_message = 4; // Дополнительное сообщение о статусе
}

// --- Сообщения для SubscribeToSWMEvents ---
message SubscriptionTopic {
  enum TopicType {
    UNDEFINED_TOPIC = 0;
    KEM_LIFECYCLE_EVENTS = 1;     // Все обновления КЕП (создание, обновление, удаление/вытеснение из SWM)
    // SYSTEM_EVENTS = 2;   // Общие системные события SWM (пока не используем)
  }
  TopicType type = 1;
  string filter_criteria = 2; // Критерии фильтрации для темы (например, "metadata.topic='project_x'" или "kem_id='id123'")
                              // Формат критериев нужно будет определить (например, простой DSL или JSONPath).
                              // Для KEM_LIFECYCLE_EVENTS это может быть фильтр по ID, типу контента, метаданным.
}

message SubscribeToSWMEventsRequest {
  string agent_id = 1; // Идентификатор агента-подписчика (для логирования и управления подписками)
  repeated SubscriptionTopic topics = 2; // Список тем, на которые агент подписывается
}

message SWMMemoryEvent {
  enum EventType {
    EVENT_TYPE_UNSPECIFIED = 0; // Используем UNSPECIFIED как значение по умолчанию согласно конвенции
    KEM_PUBLISHED = 1; // Новая КЕП опубликована в SWM (пришла от другого агента или загружена из GLM)
    KEM_UPDATED = 2;   // Существующая КЕП в SWM была обновлена (например, через PublishKEMToSWM с тем же ID)
    KEM_EVICTED = 3; // КЕП была вытеснена из кэша SWM
    // KEM_ACCESSED = 4; // Опционально: событие доступа к КЕП (может быть слишком много событий)
  }
  string event_id = 1; // Уникальный ID события
  EventType event_type = 2;
  KEM kem_payload = 3;        // КЕП, к которой относится событие.
                               // Для KEM_EVICTED может содержать только kem_id.
  google.protobuf.Timestamp event_time = 4; // Время события на сервере SWM
  string source_agent_id = 5; // Опционально: ID агента, инициировавшего событие (например, при Publish)
  string details = 6;   // Дополнительные детали о событии в текстовом формате
}

// --- Сообщения для QuerySWM ---
message QuerySWMRequest {
  // Используем KEMQuery из GLM, т.к. он уже содержит много полезных полей для запроса.
  // SWM будет пытаться выполнить этот запрос на своем внутреннем кэше.
  // Не все поля KEMQuery могут быть эффективно поддержаны на уровне кэша SWM.
  dcsm.KEMQuery query = 1; // Явно указываем пакет dcsm для KEMQuery из glm_service.proto
  int32 page_size = 2;
  string page_token = 3; // Может быть просто смещением (offset) или более сложным токеном
}

message QuerySWMResponse {
  repeated KEM kems = 1;
  string next_page_token = 2;
}

// --- Сообщения для LoadKEMsFromGLM ---
message LoadKEMsFromGLMRequest {
  // Используем KEMQuery, чтобы указать GLM, какие КЕПы нужно извлечь и загрузить в SWM.
  dcsm.KEMQuery query_for_glm = 1;
  // int32 limit_override = 2; // Можно управлять через query_for_glm.page_size или здесь
  // bool load_embeddings_if_missing = 3; // Опция для SWM, чтобы дозагрузить эмбеддинги из GLM, если их нет
}

message LoadKEMsFromGLMResponse {
  int32 kems_queried_in_glm_count = 1; // Сколько КЕП было запрошено у GLM (может отличаться от реально загруженных из-за ошибок или дубликатов)
  int32 kems_loaded_to_swm_count = 2;    // Количество КЕП, реально добавленных/обновленных в кэше SWM
  repeated string loaded_kem_ids = 3; // Список ID КЕП, которые были загружены/обновлены в SWM
  string status_message = 4;
}

// ----- Сообщения и RPC для управления блокировками -----

message AcquireLockRequest {
  string resource_id = 1; // Идентификатор ресурса, для которого запрашивается блокировка
  string agent_id = 2;    // Идентификатор агента, запрашивающего блокировку
  int32 timeout_ms = 3;   // Максимальное время ожидания блокировки в миллисекундах (0 - не ждать, -1 - ждать бесконечно)
  int32 lease_duration_ms = 4; // Запрашиваемое время удержания блокировки в мс (0 - до явного освобождения или потери связи)
                               // SWM может установить свое максимальное/минимальное время.
}

enum LockStatusValue {
  LOCK_STATUS_UNSPECIFIED = 0;
  ACQUIRED = 1;         // Блокировка успешно получена
  ALREADY_HELD_BY_YOU = 2; // Блокировка уже удерживается этим же agent_id
  TIMEOUT = 3;          // Время ожидания истекло, блокировка не получена
  NOT_AVAILABLE = 4;    // Блокировка удерживается другим агентом (если timeout_ms = 0)
  ERROR = 5;            // Произошла ошибка на сервере
}

message AcquireLockResponse {
  string resource_id = 1;
  string agent_id = 2;
  LockStatusValue status = 3;
  string lock_id = 4;         // Уникальный ID блокировки, если получена (может быть полезен для ReleaseLock)
  int64 acquired_at_unix_ms = 5; // Время получения блокировки (мс с эпохи UTC)
  int64 lease_expires_at_unix_ms = 6; // Время истечения аренды блокировки (мс с эпохи UTC), если применимо
  string message = 7;         // Дополнительное сообщение
}

message ReleaseLockRequest {
  string resource_id = 1;
  string agent_id = 2;    // Агент, который пытается освободить блокировку
  string lock_id = 3;     // Опционально: ID блокировки, полученный при AcquireLock (для проверки)
}

enum ReleaseStatusValue {
  RELEASE_STATUS_UNSPECIFIED = 0;
  RELEASED = 1;         // Блокировка успешно освобождена
  NOT_HELD = 2;         // Блокировка не удерживалась этим агентом или для этого ресурса
  INVALID_LOCK_ID = 3;  // Предоставленный lock_id не соответствует активной блокировке
  ERROR_RELEASING = 4;  // Ошибка на сервере при освобождении
}

message ReleaseLockResponse {
  string resource_id = 1;
  ReleaseStatusValue status = 2;
  string message = 3;
}

message GetLockInfoRequest {
  string resource_id = 1;
}

message LockInfo {
  string resource_id = 1;
  bool is_locked = 2;
  string current_holder_agent_id = 3; // Если is_locked = true
  string lock_id = 4;                 // Если is_locked = true
  int64 acquired_at_unix_ms = 5;      // Если is_locked = true
  int64 lease_expires_at_unix_ms = 6;   // Если is_locked = true and lease_duration_ms > 0
}
// Сервис SharedWorkingMemoryService дополняется новыми RPC
// ... (в определении service SharedWorkingMemoryService)
// rpc AcquireLock(AcquireLockRequest) returns (AcquireLockResponse);
// rpc ReleaseLock(ReleaseLockRequest) returns (ReleaseLockResponse);
// rpc GetLockInfo(GetLockInfoRequest) returns (LockInfo);

// ----- Сообщения и RPC для распределенных структур данных (начало - счетчик) -----

message DistributedCounterRequest {
  string counter_id = 1; // Уникальный идентификатор счетчика
}

message IncrementCounterRequest {
  string counter_id = 1;
  int64 increment_by = 2; // Значение, на которое увеличить счетчик (может быть отрицательным для уменьшения)
}

message CounterValueResponse {
  string counter_id = 1;
  int64 current_value = 2;
  string status_message = 3; // Для ошибок или информации
}

// ... (в определении service SharedWorkingMemoryService)
// rpc IncrementCounter(IncrementCounterRequest) returns (CounterValueResponse);
// rpc GetCounter(DistributedCounterRequest) returns (CounterValueResponse);
// rpc DeleteCounter(DistributedCounterRequest) returns (SimpleResponse); // SimpleResponse можно определить или использовать google.protobuf.Empty
// Для простоты, пока без DeleteCounter.
